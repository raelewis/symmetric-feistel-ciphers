"""
Rachel Lewis
Spring 2023
CS 665
"""

import argparse
import logging
import time
import base64


parser = argparse.ArgumentParser(description='Program encrypts/decrypts message using a simple feistel cipher.')
parser.add_argument('message', metavar='msg', type=str, help='Text that is to be encrypted / decrypted.')
parser.add_argument('-e', action='store_true', help='performs encryption (default case if unspecified)', default=True)
parser.add_argument('-d', action='store_true', help='performs decryption on a base64 encoded string', default=False)
parser.add_argument('-K', metavar='key', help='key used for cipher', required=True) 
parser.add_argument('-r', action='store_true', help='msg stores the name of the file to read from', default=False)
parser.add_argument('-w', metavar='write', help='provides the filename for the program to write text to', required=False)
parser.add_argument('-iter', metavar='iteration', help='Number of rounds used for the process up to 32', required=False)
parser.add_argument('-N', metavar='bits', help='number of bits for each data block', required=False)
parser.add_argument('-l', metavar='log', help='name of the log file generated by process', required=False)
args = parser.parse_args()


if (args.N):
    N = int(args.N)         
else:
    N = 64

if(args.iter):
    r = int(args.iter)
else:
    r = 16

if (args.d):
    args.e = False
else:
    args.e = True

# FIX THIS IS BAD HAHA
KEY_SIZE = N//2     

# Determines the name of the log file.
if(args.l):
    path = "logs/" + args.l + ".log"
else:
    path = "logs/" + time.strftime("%d %b %H:%M:%S") + ".log"


def convert_to_bin(s):
    """ Converts a string into ascii and then binary"""
    ascii_text = [ord(i) for i in s]
    bin_text = [format(j, '08b') for j in ascii_text]
    _bin = "".join(bin_text)
    return _bin


def decode_base64(s):
    """If decryption is chosen, decode base64 into useable format for program."""
    text = s.encode('ascii')
    decoded_text = base64.decodebytes(text)
    bit_text = ("".join(["{:08b}".format(x) for x in decoded_text]))
    return bit_text


def encode_base64(s):
    """Converts the ciphertext into base64 for output."""
    bit_text = int(s, 2).to_bytes((len(s) + 7) // 8, byteorder='big')
    encoded_text = base64.b64encode(bit_text)
    base64_text = encoded_text.decode('ascii')
    return base64_text
    

def pad_binary(s, n):
    """ Pads the end of a binary string with 0s to ensure it is of len % n == 0 OR >= size of data """
    if(len(s) % n != 0):
        if(len(s) < n):
            temp = n - (len(s))
        else:
            temp = N - (len(s) % n)
        s = s.zfill(len(s)+temp)
    return s


def convert_to_text(s):
    """ Converts every 8 bits into the corresponding ascii char and back to readable string. """
    n = 8
    text = ""
    _bin = [int(s[x:x+n],2) for x in range(0, len(s), n)]
    for x in range(0, len(_bin), 1):
        text += chr(_bin[x])
    return text


def generate_subkey(key, i):
    """ Creates a subkey based on round i. """
    temp = int(key)
    temp += i
    if (args.d):
        temp -= 1

    return temp


def key_schedule(key):
    bin_key = convert_to_bin(key)
    bin_key = pad_binary(bin_key, KEY_SIZE)
    return ks_shift(bin_key)


def ks_add(key):
    """Initial iteration of the key schedule that uses basic arithmetic to generate all subkeys."""
    subkey = []
    int_key = int(key,2)
    for x in range(0, r, 1):
        tmp = bin(int_key + x)
        subkey.append(convert_to_bin(tmp))
    return subkey


def ks_shift(key):
    """Key schedule that follows the left shift table used by DES."""
    shift_list = [1, 1, 2, 2, 2, 2, 2, 2,
                  2, 1, 2, 2, 2, 2, 2, 1,
                  1, 1, 2, 2, 2, 2, 2, 2,
                  2, 1, 2, 2, 2, 2, 2, 1]
    subkey = []
    tmp = key
    for x in range(0, r, 1):
        tmp = left_shift(tmp, shift_list[x])
        subkey.append(tmp)
    return subkey


def xor(l, r):
    xor = ""
    for i in range(0, len(l), 1):
        temp = int(l[i]) ^ int(r[i])
        xor += str(temp)
    return xor


def left_shift(s, l):
    s = s[l:] + s[:l]
    return s
        

def round_function(R, key):
    """ Performs the round function on the right side of the block with subkey key. """
    right = xor(R, key)
    return right


def round(loop, R, L, key):
    """ Performs each round of the encryption / decryption of the block cipher """
    for i in range(loop[0], loop[1], loop[2]):
        r_temp = R
        R = round_function(R, key[i])
        R = xor(L, R)
        L = r_temp
    return L, R


def split_block(bin_text, key):
    """ Splits the block into L and R and returns the text after R rounds. """
    mid = int((len(bin_text)//2))
    L = bin_text[:mid]
    R = bin_text[mid:]

    # If Encryption
    if (args.e):
        L, R = round((0, r, 1), R, L, key)
    # Decryption
    else:
        R, L = round((r-1, -1, -1), L, R, key)
    return L + R
    

def split_data(s, key):
    """ Splits the data item N bit chunks. Calls split_block on each chunk of data 
    and returns the subsequent enc/dec text. """
    datablock = []
    temp = []
    text = ""

    if (args.e):
        _bin = convert_to_bin(s)
        _bin = pad_binary(_bin, N)
    else:
        _bin = decode_base64(s)

    subkeys = key_schedule(key)
    for x in range(0, len(_bin), N):
        datablock.append(_bin[x:(N+x)])
    for x in range(0, len(datablock), 1):
        temp.append(split_block(datablock[x], subkeys))
    text = "".join(temp)
    if (args.e):
        text = encode_base64(text)
    else:
        text = convert_to_text(text)
            
    # Adjust ENC / DEC flags for second part.
    if (args.e):
        args.e = False
        args.d = True
    else:
        args.d = False
        args.e = True
    return text


def encryption(plaintext, key):
    """ Return the encrypted ciphertext from the given plaintext and key. """
    plaintext2 = ""
    logging.debug("Plaintext:   %s", plaintext)
    logging.debug("Key:         %s", key)
    ciphertext = split_data(plaintext, key)
    logging.debug("Ciphertext:  %s", ciphertext)
    plaintext2 = split_data(ciphertext, key)
    # A temporary solution to the padded 0s.
    plaintext2 = plaintext2.replace("\x00", '')
    logging.debug("Plaintext:   %s", plaintext2)

    for i in range(len(plaintext2), 0, -1):
        if plaintext2[i-1] == "\b0x00":
            logging.warning("Null char!")
    if (plaintext == plaintext2):
        logging.info("Check complete, returning ciphertext.")
        return ciphertext
    else:
        logging.error("Encryption / Decryption incorrect. Exiting...")
        return "Error"


def decryption(ciphertext, key):
    """ Return the decrypted plaintext from the given ciphertext and key.  """
    logging.debug("Ciphertext:   %s", ciphertext)
    logging.debug("Key:         %s", key)
    plaintext = split_data(ciphertext, key)
    logging.debug("plaintext:  %s", plaintext)
    ciphertext2 = split_data(plaintext, key)
    logging.debug("Ciphertext:   %s", ciphertext2)
    if (ciphertext == ciphertext2):
        logging.info("Check complete, returning plaintext.")
        plaintext = plaintext.replace("\x00", '')
        return plaintext
    else:
        logging.error("Encryption / Decryption incorrect. Exiting...")
        plaintext = plaintext.replace("\x00", '')
        return plaintext


def main():
    logging.basicConfig(format='%(asctime)s %(levelname)s %(message)s', 
                        datefmt='%m/%d/%Y %I:%M:%S %p',
                        filename=path, 
                        encoding='utf-8', 
                        level=logging.DEBUG)
    logging.info("Command Line Variables")
    logging.debug("args.e: %s", args.e)
    logging.debug("args.d: %s", args.d)
    logging.debug("args.K: %s", args.K)
    logging.debug("args.r: %s", args.r)
    logging.debug("args.w: %s", args.w)
    logging.debug("args.iter: %s", args.iter)
    logging.debug("args.N: %s", args.N)
    logging.debug("args.l: %s", args.l)

    # This section handles File IO (if specified by the user).
    text = ""
    if (args.r):
        with open(args.message) as file:
            text = file.read()
    else:
        text = args.message

    # This determines if the program is performing encryption or decryption
    if (args.d):
        text = decryption(text, args.K)
    else:
        text = encryption(text, args.K)

    # This writes the output of the process to a file if given a filename or to the console.
    if (args.w):
        with open(args.w, "w") as file:
            file.write(text)
    else:
        print(text)  
    

if __name__=="__main__":
    main()