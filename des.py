"""
Rachel Lewis
Spring 2023 CS F665
A simple DES implementation in Python. 
"""

import argparse
import base64
import cProfile
import logging
import time


# Argparse setup for the command line prompts.
parser = argparse.ArgumentParser(description='Program encrypts/decrypts message using a simple feistel cipher.')
parser.add_argument('message', metavar='msg', type=str, help='Text that is to be encrypted / decrypted.')
parser.add_argument('-e', action='store_true', help='performs encryption (default case if unspecified)', default=True)
parser.add_argument('-d', action='store_true', help='performs decryption on a base64 encoded string', default=False)
parser.add_argument('-K', metavar='key', help='key used for cipher', required=True) 
parser.add_argument('-r', action='store_true', help='msg stores the name of the file to read from', default=False)
parser.add_argument('-w', metavar='write', help='provides the filename for the program to write text to', required=False)
parser.add_argument('-l', metavar='log', help='name of the log file generated by process', required=False)
args = parser.parse_args()


N = 64      # Bit Number
r = 16      # Round Number

# Determines the name of the log file.
if(args.l):
    path = "logs/" + args.l + ".log"
else:
    path = "logs/" + time.strftime("%d %b %H:%M:%S") + ".log"

# The following are the various DES permutation boxes.
PC1 = [57, 49, 41, 33, 25, 17, 9,
        1, 58, 50, 42, 34, 26, 18,
        10, 2, 59, 51, 43, 35, 27,
        19, 11, 3, 60, 52, 44, 36,
        63, 55, 47, 39, 31, 23, 15,
        7,  62, 54, 46, 38, 30, 22,
        14, 6, 61, 53, 45, 37, 29,
        21, 13, 5, 28, 20, 12, 4]

PC2 = [14, 17, 11, 24, 1, 5,
        3, 28, 15, 6, 21, 10,
        23, 19, 12, 4, 26, 8,
        16, 7, 27, 20, 13, 2,
        41, 52, 31, 37, 47, 55,
        30, 40, 51, 45, 33, 48,
        44, 49, 39, 56, 34, 53,
        46, 42, 50, 36, 29, 32]


def convert_to_bin(s):
    """ Converts a string into ascii and then binary"""
    ascii_text = [ord(i) for i in s]
    bin_text = [format(j, '08b') for j in ascii_text]
    _bin = "".join(bin_text)
    return _bin


def decode_base64(s):
    """If decryption is chosen, decode base64 into useable format for program."""
    text = s.encode('ascii')
    decoded_text = base64.decodebytes(text)
    bit_text = ("".join(["{:08b}".format(x) for x in decoded_text]))
    return bit_text


def encode_base64(s):
    """Converts the ciphertext into base64 for output."""
    bit_text = int(s, 2).to_bytes((len(s) + 7) // 8, byteorder='big')
    encoded_text = base64.b64encode(bit_text)
    base64_text = encoded_text.decode('ascii')
    return base64_text


def pad_binary(s, n):
    """ Pads the end of a binary string with 0s to ensure it is of len % n == 0 OR >= size of data """
    if(len(s) % n != 0):
        if(len(s) < n):
            temp = n - (len(s))
        else:
            temp = N - (len(s) % n)
        s = s.zfill(len(s)+temp)
    return s


def convert_to_text(s):
    """ Converts every 8 bits into the corresponding ascii char and back to readable string. """
    n = 8
    text = ""
    _bin = [int(s[x:x+n],2) for x in range(0, len(s), n)]
    for x in range(0, len(_bin), 1):
        text += chr(_bin[x])
    return text


def key_schedule(key):
    "This mimics the key schedule of DES for testing purposes."
    k, pc1, pc2 = "", "", ""
    c, d, cd = [], [], []
    k = convert_to_bin(key)
    k = k[:64]
    k = pad_binary(k, 64)

    for x in range(0, len(PC1), 1):
        pc1 += k[PC1[x]-1]

    c0 = pc1[:(len(pc1)//2)]
    d0 = pc1[(len(pc1)//2):]
    c.append(c0)
    d.append(d0)

    shift_list = [1, 1, 2, 2, 2, 2, 2, 2,
                  2, 1, 2, 2, 2, 2, 2, 1]
    
    for x in range(1, 17, 1):
        c.append(left_shift(c[x-1], shift_list[x-1]))
        d.append(left_shift(d[x-1], shift_list[x-1]))

    for x in range(1, len(c), 1):
        tmp = c[x] + d[x]
        for y in range(0, len(PC2), 1):
            pc2 += tmp[PC2[y]-1]
        cd.append(pc2)

    return cd


def xor(l, r):
    xor = ""
    for i in range(0, len(l), 1):
        temp = int(l[i]) ^ int(r[i])
        xor += str(temp)
    return xor


def left_shift(s, l):
    s = s[l:] + s[:l]
    return s


def expansion(R):
    """ Performs DES expansion on the given block to ensure the 32 bit block befores 48 bits. """
    right = ""
    expan = [ 32,  1,  2,  3,  4,  5,
               4,  5,  6,  7,  8,  9,
               8,  9,  10, 11, 12, 13,
              12,  13, 14, 15, 16, 17,
              16,  17, 18, 19, 20, 21,
              20,  21, 22, 23, 24, 25,
              24,  25, 26, 27, 28, 29,
              28,  29, 30, 31, 32, 1 ]
    for x in range(0, len(expan), 1):
        right += R[expan[x]-1]
    return right


def s_box(R):
    right = ""
    s_box = [2, 3, 4, 5,
            8, 9, 10, 11,
            14, 15, 16, 17,
            20, 21, 22, 23,
            26, 27, 28, 29,
            32, 33, 34, 35,
            38, 39, 40, 41,
            44, 45, 46, 47]
    for x in range(0, len(s_box), 1):
        right += R[s_box[x]-1]
    return right


def initial_perm(R):
    ip =   [58, 50, 42, 34, 26, 18, 10, 2,
                60, 52, 44, 36, 28, 20, 12, 4,
                62, 54, 46, 38, 30, 22, 14, 6,
                64, 56, 48, 40, 32, 24, 16, 8,
                57, 49, 41, 33, 25, 17, 9, 1,
                59, 51, 43, 35, 27, 19, 11, 3,
                61, 53, 45, 37, 29, 21, 13, 5,
                63, 55, 47, 39, 31, 23, 15, 7]
    right = ""
    for x in range(0, len(ip), 1):
        right += R[ip[x]-1]
    return right


def final_perm(R):
    fp = [40, 8, 48, 16, 56, 24, 64, 32,
            39, 7, 47, 15, 55, 23, 63, 31,
            38, 6, 46, 14, 54, 22, 62, 30,
            37, 5, 45, 13, 53, 21, 61, 29,
            36, 4, 44, 12, 52, 20, 60, 28,
            35, 3, 43, 11, 51, 19, 59, 27,
            34, 2, 42, 10, 50, 18, 58, 26,
            33, 1, 41, 9, 49, 17, 57, 25]
    right = ""
    for x in range(0, len(fp), 1):
        right += R[fp[x]-1]
    return right


def round_function(R, key):
    """ Performs the round function on the right side of the block with subkey key. """
    R = expansion(R)
    right = xor(R, key)
    right = s_box(right)
    rp = ""
    p = [16, 7, 20, 21, 29, 12, 28, 17,
            1, 15, 23, 26, 5, 18, 31, 10,
            2, 8, 24, 14, 32, 27, 3, 9,
            19, 13, 30, 6, 22, 11, 4, 25]    
    for x in range(0, len(p), 1):
        rp += right[p[x]-1]
    return rp


def round(loop, R, L, key):
    """ Performs each round of the encryption / decryption of the block cipher """
    for i in range(loop[0], loop[1], loop[2]):
        r_temp = R
        R = round_function(R, key[i])
        R = xor(L, R)
        L = r_temp
    return L, R


def split_block(bin_text, key):
    """ Splits the block into L and R and returns the text after R rounds. """
    text = initial_perm(bin_text)
    mid = int((len(text)//2))
    L = text[:mid]
    R = text[mid:]

    if (args.e):
        L, R = round((0, r, 1), R, L, key)

    else:
        R, L = round((r-1, -1, -1), L, R, key)
    return final_perm(L + R)


def split_data(s, key):
    """ Splits the data item N bit chunks. Calls split_block on each chunk of data and returns the subsequent enc/dec text. """
    datablock = []
    temp = []
    text = ""
    
    if (args.e):
        _bin = convert_to_bin(s)
        _bin = pad_binary(_bin, N)
    else:
        _bin = decode_base64(s)
    
    subkeys = key_schedule(key)

    for x in range(0, len(_bin), N):
        datablock.append(_bin[x:(N+x)])
    for x in range(0, len(datablock), 1):
        temp.append(split_block(datablock[x], subkeys))

    text = "".join(temp)
    if (args.e):
        text = encode_base64(text)
    else:
        text = convert_to_text(text)
            
    return text


def encryption(plaintext, key):
    """ Return the encrypted ciphertext from the given plaintext and key. """
    logging.debug("Plaintext:   %s", plaintext)
    logging.debug("Key:         %s", key)
    ciphertext = split_data(plaintext, key)
    logging.debug("Ciphertext:  %s", ciphertext)
    return ciphertext


def decryption(ciphertext, key):
    """ Return the decrypted plaintext from the given ciphertext and key.  """
    logging.debug("Ciphertext:   %s", ciphertext)
    logging.debug("Key:         %s", key)
    plaintext = split_data(ciphertext, key)
    plaintext = plaintext.replace("\x00", '')
    logging.debug("plaintext:  %s", plaintext)
    return plaintext


def main():
    logging.basicConfig(format='%(asctime)s %(levelname)s %(message)s', 
                        datefmt='%m/%d/%Y %I:%M:%S %p',
                        filename=path, 
                        encoding='utf-8', 
                        level=logging.DEBUG)
    logging.info("Command Line Variables")
    logging.debug("args.e: %s", args.e)
    logging.debug("args.d: %s", args.d)
    logging.debug("args.K: %s", args.K)
    logging.debug("args.r: %s", args.r)
    logging.debug("args.w: %s", args.w)
    logging.debug("args.l: %s", args.l)

    # This section handles File IO (if specified by the user).
    text = ""
    if (args.r):
        with open(args.message, "r") as file:
            text = file.read()
    else:
        text = args.message

    # This determines if the program is performing encryption or decryption
    if (args.d):
        text = decryption(text, args.K)
    else:
        text = encryption(text, args.K)

    # This writes the output of the process to a file if given a filename or to the console.
    if (args.w):
        with open(args.w, "w") as file:
            file.write(text)
    else:
        print(text)  
    

if __name__=="__main__":
    cProfile.run('main()')